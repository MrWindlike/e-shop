### 为什么Nodejs是单线程的？
在其他服务端语言中（比如PHP，Java），一般采用多线程的方式来处理多任务的执行。多线程在提升代码的执行效率的同时，也带来一些问题：
1. 多线程导致代码复杂度上升，需要使用额外的代码去管理多线程之间的执行
2. 每一个请求会分配一个线程去处理，当并发量大于线程可分配数量时，剩下的请求则会被拒绝

基于以上多线程的一些缺点，Nodejs决定采用单JS主线程+多I/O线程的方式来执行代码，然后采用事件循环的机制来处理多任务。

### 事件循环
当程序有监听的事件时，Nodejs会一直执行事件循环，直到没有任何监听的事件为止。

每轮事件循环可以分为以下六个阶段：
1. timers: 执行已到时间的定时器
2. I/O callbacks: 执行上一次剩下的I/O回调
3. idle, prepare: 预留给系统的阶段
4. poll: 执行I/O完成的回调
5. check: 执行`setimmediate`的回调
6. close callbacks: 执行`close`事件的回调

然后每个阶段执行完成后，会执行微任务队列的所有任务
```js
   ┌───────────────────────┐
┌─>│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │<──connections───     │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
```

### Nodejs是怎么运行在操作系统上的
|----------------------------------------------|
|                 Nodejs API                   |
|----------------------------------------------|
|                   C++ Lib                    |
|                                              |
|     V8     |     libuv    |    DNS Lookup    |
|                   ...                        |
|----------------------------------------------|

Nodejs API: 提供JavaScript编写的各种API
V8: JavaScript执行引擎
libuv: 提供线程池，异步I/O等功能，用于实现事件循环

